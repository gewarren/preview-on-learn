(()=>{"use strict";const e="checkToken",t="getToken";class n{async hasGitHubToken(){return new Promise(t=>{chrome.runtime.sendMessage({type:e},e=>{t(e?.hasToken||!1)})})}async getGitHubToken(){return new Promise(e=>{chrome.runtime.sendMessage({type:t},t=>{e(t?.token||null)})})}}class r{constructor(e){this.encryption=e}async hasGitHubToken(){try{const e=await chrome.storage.session.get(["githubToken"]);if(!e.githubToken)return!1;try{return await this.encryption.decryptToken(e.githubToken),!0}catch(e){return console.warn("Found invalid encrypted token, clearing it:",e),await chrome.storage.session.remove("githubToken"),!1}}catch(e){return console.error("Error checking for GitHub token:",e),!1}}async getGitHubToken(){try{const e=await chrome.storage.session.get(["githubToken"]);if(!e.githubToken)return null;try{return await this.encryption.decryptToken(e.githubToken)}catch(e){return console.warn("Found invalid encrypted token, clearing it:",e),await chrome.storage.session.remove("githubToken"),null}}catch(e){return console.error("Error getting GitHub token:",e),null}}}const o=function(e=null){return function(){try{return"undefined"!=typeof chrome&&void 0!==chrome.runtime&&"undefined"!=typeof window&&window.location&&window.location.protocol.startsWith("http")}catch(e){return!1}}()?new n:new r(e)}(new class{constructor(){this.algorithm="AES-GCM",this.keyLength=256}async generateKey(){return await crypto.subtle.generateKey({name:this.algorithm,length:this.keyLength},!0,["encrypt","decrypt"])}async deriveKeyFromPassword(e){const t=new TextEncoder,n=t.encode(e),r=await crypto.subtle.importKey("raw",n,"PBKDF2",!1,["deriveBits","deriveKey"]);return await crypto.subtle.deriveKey({name:"PBKDF2",salt:t.encode("preview-on-learn-salt"),iterations:1e5,hash:"SHA-256"},r,{name:this.algorithm,length:this.keyLength},!1,["encrypt","decrypt"])}async getEncryptionKey(){const e=navigator.userAgent+"preview-on-learn-key-2025";return await this.deriveKeyFromPassword(e)}async encryptToken(e){try{const t=await this.getEncryptionKey(),n=(new TextEncoder).encode(e),r=crypto.getRandomValues(new Uint8Array(12)),o=await crypto.subtle.encrypt({name:this.algorithm,iv:r},t,n),i=new Uint8Array(r.length+o.byteLength);return i.set(r,0),i.set(new Uint8Array(o),r.length),btoa(String.fromCharCode(...i))}catch(e){throw console.error("Error encrypting token:",e),new Error("Failed to encrypt token")}}async decryptToken(e){try{const t=await this.getEncryptionKey(),n=new Uint8Array(atob(e).split("").map(e=>e.charCodeAt(0))),r=n.slice(0,12),o=n.slice(12),i=await crypto.subtle.decrypt({name:this.algorithm,iv:r},t,o);return(new TextDecoder).decode(i)}catch(e){throw console.error("Error decrypting token:",e),new Error("Failed to decrypt token")}}});chrome.runtime.onMessage.addListener((n,r,i)=>n.type===e?(o.hasGitHubToken().then(e=>{i({hasToken:e})}).catch(e=>{console.error("Error checking token:",e),i({hasToken:!1})}),!0):n.type===t?(o.getGitHubToken().then(e=>{i({token:e})}).catch(e=>{console.error("Error getting token:",e),i({token:null})}),!0):void 0)})();